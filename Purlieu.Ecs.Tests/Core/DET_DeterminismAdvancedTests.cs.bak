using NUnit.Framework;
using PurlieuEcs.Core;
using PurlieuEcs.Systems;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Purlieu.Ecs.Tests.Core;

[TestFixture]
public class DET_DeterminismAdvancedTests
{
    private const float FixedDeltaTime = 0.016666667f; // 60 FPS
    private const int RandomSeed = 12345;

    [Test]
    public void DET_FixedSeed_IdenticalWorldStates()
    {
        var world1 = CreateDeterministicWorld();
        var world2 = CreateDeterministicWorld();

        // Run identical simulations
        for (int frame = 0; frame < 100; frame++)
        {
            UpdateWorld(world1, frame);
            UpdateWorld(world2, frame);
        }

        // Compare final world states
        AssertWorldsIdentical(world1, world2);
    }

    [Test]
    public void DET_MultipleRuns_SameResults()
    {
        var results = new List<WorldSnapshot>();

        // Run the same simulation 5 times
        for (int run = 0; run < 5; run++)
        {
            var world = CreateDeterministicWorld();
            
            for (int frame = 0; frame < 50; frame++)
            {
                UpdateWorld(world, frame);
            }
            
            results.Add(CaptureWorldSnapshot(world));
        }

        // All results should be identical
        for (int i = 1; i < results.Count; i++)
        {
            AssertSnapshotsIdentical(results[0], results[i], $"Run {i} differs from Run 0");
        }
    }

    [Test]
    public void DET_SystemOrder_Consistency()
    {
        // Test that system execution order doesn't affect determinism
        var world1 = CreateDeterministicWorld();
        var world2 = CreateDeterministicWorld();
        
        var scheduler1 = new SystemScheduler();
        var scheduler2 = new SystemScheduler();

        // Register systems in different orders
        scheduler1.RegisterSystem(new DeterministicMovementSystem(RandomSeed));
        scheduler1.RegisterSystem(new DeterministicPhysicsSystem(RandomSeed + 1));
        scheduler1.RegisterSystem(new DeterministicAISystem(RandomSeed + 2));

        scheduler2.RegisterSystem(new DeterministicAISystem(RandomSeed + 2));
        scheduler2.RegisterSystem(new DeterministicPhysicsSystem(RandomSeed + 1));
        scheduler2.RegisterSystem(new DeterministicMovementSystem(RandomSeed));

        // Run simulations
        for (int frame = 0; frame < 30; frame++)
        {
            scheduler1.UpdatePhase(world1, FixedDeltaTime, GamePhases.Update);
            scheduler2.UpdatePhase(world2, FixedDeltaTime, GamePhases.Update);
        }

        AssertWorldsIdentical(world1, world2);
    }

    [Test]
    public void DET_EntityCreationOrder_Deterministic()
    {
        var world1 = new World();
        var world2 = new World();

        var entities1 = new List<Entity>();
        var entities2 = new List<Entity>();

        // Create entities in same pattern
        var random1 = new Random(RandomSeed);
        var random2 = new Random(RandomSeed);

        for (int i = 0; i < 100; i++)
        {
            // Randomly decide whether to create an entity this iteration
            if (random1.Next(10) < 7) // 70% chance
            {
                entities1.Add(world1.CreateEntity());
            }
            if (random2.Next(10) < 7) // 70% chance
            {
                entities2.Add(world2.CreateEntity());
            }
        }

        Assert.That(entities1.Count, Is.EqualTo(entities2.Count));
        
        // Entity IDs should be identical
        for (int i = 0; i < entities1.Count; i++)
        {
            Assert.That(entities1[i], Is.EqualTo(entities2[i]), 
                $"Entity {i} ID mismatch: {entities1[i]} vs {entities2[i]}");
        }
    }

    [Test]
    public void DET_ComponentAddRemove_Deterministic()
    {
        var world1 = CreateDeterministicWorld();
        var world2 = CreateDeterministicWorld();

        var random1 = new Random(RandomSeed);
        var random2 = new Random(RandomSeed);

        // Perform identical random component operations
        for (int frame = 0; frame < 50; frame++)
        {
            var entities1 = GetAllEntities(world1);
            var entities2 = GetAllEntities(world2);

            for (int i = 0; i < Math.Min(entities1.Count, entities2.Count); i++)
            {
                var operation1 = random1.Next(4); // 0-3 operations
                var operation2 = random2.Next(4);

                Assert.That(operation1, Is.EqualTo(operation2));

                switch (operation1)
                {
                    case 0: // Add Position
                        if (!world1.HasComponent<DeterministicPosition>(entities1[i]))
                        {
                            world1.AddComponent(entities1[i], new DeterministicPosition { X = random1.NextSingle(), Y = random1.NextSingle() });
                            world2.AddComponent(entities2[i], new DeterministicPosition { X = random2.NextSingle(), Y = random2.NextSingle() });
                        }
                        break;
                    case 1: // Remove Position
                        if (world1.HasComponent<DeterministicPosition>(entities1[i]))
                        {
                            world1.RemoveComponent<DeterministicPosition>(entities1[i]);
                            world2.RemoveComponent<DeterministicPosition>(entities2[i]);
                        }
                        break;
                    case 2: // Add Velocity
                        if (!world1.HasComponent<DeterministicVelocity>(entities1[i]))
                        {
                            world1.AddComponent(entities1[i], new DeterministicVelocity { X = random1.NextSingle() * 2 - 1, Y = random1.NextSingle() * 2 - 1 });
                            world2.AddComponent(entities2[i], new DeterministicVelocity { X = random2.NextSingle() * 2 - 1, Y = random2.NextSingle() * 2 - 1 });
                        }
                        break;
                    case 3: // Remove Velocity
                        if (world1.HasComponent<DeterministicVelocity>(entities1[i]))
                        {
                            world1.RemoveComponent<DeterministicVelocity>(entities1[i]);
                            world2.RemoveComponent<DeterministicVelocity>(entities2[i]);
                        }
                        break;
                }
            }
        }

        AssertWorldsIdentical(world1, world2);
    }

    [Test]
    public void DET_QueryIteration_OrderConsistent()
    {
        var world = CreateDeterministicWorld();
        
        // Capture query results multiple times
        var results1 = new List<(Entity, DeterministicPosition, DeterministicVelocity)>();
        var results2 = new List<(Entity, DeterministicPosition, DeterministicVelocity)>();
        var results3 = new List<(Entity, DeterministicPosition, DeterministicVelocity)>();

        var query = world.Query().With<DeterministicPosition>().With<DeterministicVelocity>();

        // First capture
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<DeterministicPosition>();
            var velocities = chunk.GetSpan<DeterministicVelocity>();

            for (int i = 0; i < chunk.Count; i++)
            {
                results1.Add((chunk.GetEntity(i), positions[i], velocities[i]));
            }
        }

        // Second capture (should be identical)
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<DeterministicPosition>();
            var velocities = chunk.GetSpan<DeterministicVelocity>();

            for (int i = 0; i < chunk.Count; i++)
            {
                results2.Add((chunk.GetEntity(i), positions[i], velocities[i]));
            }
        }

        // Third capture after some operations
        UpdateWorld(world, 1);
        
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<DeterministicPosition>();
            var velocities = chunk.GetSpan<DeterministicVelocity>();

            for (int i = 0; i < chunk.Count; i++)
            {
                results3.Add((chunk.GetEntity(i), positions[i], velocities[i]));
            }
        }

        Assert.That(results1.Count, Is.EqualTo(results2.Count));
        for (int i = 0; i < results1.Count; i++)
        {
            Assert.That(results1[i].Item1, Is.EqualTo(results2[i].Item1), "Entity order changed between queries");
        }
    }

    [Test]
    public void DET_FloatingPoint_Precision()
    {
        // Test that floating-point operations remain deterministic
        var world1 = new World();
        var world2 = new World();

        // Create entities with precise floating-point components
        for (int i = 0; i < 100; i++)
        {
            var entity1 = world1.CreateEntity();
            var entity2 = world2.CreateEntity();

            float x = i * 0.1f + 0.333333333f;
            float y = i * 0.2f + 0.666666666f;

            world1.AddComponent(entity1, new DeterministicPosition { X = x, Y = y });
            world2.AddComponent(entity2, new DeterministicPosition { X = x, Y = y });

            world1.AddComponent(entity1, new DeterministicVelocity { X = (float)Math.Sin(i), Y = (float)Math.Cos(i) });
            world2.AddComponent(entity2, new DeterministicVelocity { X = (float)Math.Sin(i), Y = (float)Math.Cos(i) });
        }

        var system1 = new DeterministicFloatSystem();
        var system2 = new DeterministicFloatSystem();

        // Run floating-point intensive operations
        for (int frame = 0; frame < 100; frame++)
        {
            system1.Update(world1, FixedDeltaTime);
            system2.Update(world2, FixedDeltaTime);
        }

        AssertWorldsIdentical(world1, world2);
    }

    [Test]
    public void DET_EventSystem_Determinism()
    {
        var world1 = new World();
        var world2 = new World();

        var system1 = new DeterministicEventSystem(RandomSeed);
        var system2 = new DeterministicEventSystem(RandomSeed);

        // Create entities that will trigger events
        for (int i = 0; i < 20; i++)
        {
            var entity1 = world1.CreateEntity();
            var entity2 = world2.CreateEntity();

            world1.AddComponent(entity1, new DeterministicEventTrigger { TriggerFrame = i % 10 });
            world2.AddComponent(entity2, new DeterministicEventTrigger { TriggerFrame = i % 10 });
        }

        // Run systems and capture events
        var events1 = new List<DeterministicEvent>();
        var events2 = new List<DeterministicEvent>();

        for (int frame = 0; frame < 20; frame++)
        {
            system1.Update(world1, FixedDeltaTime);
            system2.Update(world2, FixedDeltaTime);

            world1.Events<DeterministicEvent>().ConsumeAll(evt => events1.Add(evt));
            world2.Events<DeterministicEvent>().ConsumeAll(evt => events2.Add(evt));
        }

        Assert.That(events1.Count, Is.EqualTo(events2.Count));
        for (int i = 0; i < events1.Count; i++)
        {
            Assert.That(events1[i].Id, Is.EqualTo(events2[i].Id));
            Assert.That(events1[i].Value, Is.EqualTo(events2[i].Value).Within(0.00001f));
        }
    }

    [Test]
    public void DET_ArchetypeTransitions_Deterministic()
    {
        var world1 = new World();
        var world2 = new World();

        var random1 = new Random(RandomSeed);
        var random2 = new Random(RandomSeed);

        // Create initial entities
        var entities1 = new List<Entity>();
        var entities2 = new List<Entity>();

        for (int i = 0; i < 50; i++)
        {
            entities1.Add(world1.CreateEntity());
            entities2.Add(world2.CreateEntity());
        }

        // Perform random archetype transitions
        for (int iteration = 0; iteration < 100; iteration++)
        {
            for (int i = 0; i < entities1.Count; i++)
            {
                var operation1 = random1.Next(6);
                var operation2 = random2.Next(6);
                Assert.That(operation1, Is.EqualTo(operation2));

                ApplyArchetypeOperation(world1, entities1[i], operation1, random1);
                ApplyArchetypeOperation(world2, entities2[i], operation2, random2);
            }
        }

        AssertWorldsIdentical(world1, world2);
    }

    // Helper Methods
    private World CreateDeterministicWorld()
    {
        var world = new World();
        var random = new Random(RandomSeed);

        // Create deterministic initial state
        for (int i = 0; i < 50; i++)
        {
            var entity = world.CreateEntity();
            
            if (random.Next(10) < 8) // 80% chance
            {
                world.AddComponent(entity, new DeterministicPosition { X = random.NextSingle() * 100, Y = random.NextSingle() * 100 });
            }
            
            if (random.Next(10) < 6) // 60% chance
            {
                world.AddComponent(entity, new DeterministicVelocity { X = (random.NextSingle() - 0.5f) * 10, Y = (random.NextSingle() - 0.5f) * 10 });
            }
            
            if (random.Next(10) < 4) // 40% chance
            {
                world.AddComponent(entity, new DeterministicHealth { Current = random.Next(50, 100), Maximum = 100 });
            }
        }

        return world;
    }

    private void UpdateWorld(World world, int frameNumber)
    {
        var system = new DeterministicMovementSystem(RandomSeed + frameNumber);
        system.Update(world, FixedDeltaTime);
    }

    private List<Entity> GetAllEntities(World world)
    {
        var entities = new List<Entity>();
        var query = world.Query(); // Query all entities
        
        foreach (var chunk in query.Chunks())
        {
            for (int i = 0; i < chunk.Count; i++)
            {
                entities.Add(chunk.GetEntity(i));
            }
        }
        
        return entities;
    }

    private void ApplyArchetypeOperation(World world, Entity entity, int operation, Random random)
    {
        switch (operation)
        {
            case 0: // Add Position
                if (!world.HasComponent<DeterministicPosition>(entity))
                    world.AddComponent(entity, new DeterministicPosition { X = random.NextSingle(), Y = random.NextSingle() });
                break;
            case 1: // Remove Position
                if (world.HasComponent<DeterministicPosition>(entity))
                    world.RemoveComponent<DeterministicPosition>(entity);
                break;
            case 2: // Add Velocity
                if (!world.HasComponent<DeterministicVelocity>(entity))
                    world.AddComponent(entity, new DeterministicVelocity { X = random.NextSingle(), Y = random.NextSingle() });
                break;
            case 3: // Remove Velocity
                if (world.HasComponent<DeterministicVelocity>(entity))
                    world.RemoveComponent<DeterministicVelocity>(entity);
                break;
            case 4: // Add Health
                if (!world.HasComponent<DeterministicHealth>(entity))
                    world.AddComponent(entity, new DeterministicHealth { Current = random.Next(1, 100), Maximum = 100 });
                break;
            case 5: // Remove Health
                if (world.HasComponent<DeterministicHealth>(entity))
                    world.RemoveComponent<DeterministicHealth>(entity);
                break;
        }
    }

    private WorldSnapshot CaptureWorldSnapshot(World world)
    {
        var snapshot = new WorldSnapshot();
        
        var query = world.Query();
        foreach (var chunk in query.Chunks())
        {
            var entities = chunk.GetEntities();
            for (int i = 0; i < chunk.Count; i++)
            {
                var entity = entities[i];
                var entityData = new EntitySnapshot { Entity = entity };

                if (world.HasComponent<DeterministicPosition>(entity))
                {
                    entityData.Position = world.GetComponent<DeterministicPosition>(entity);
                    entityData.HasPosition = true;
                }

                if (world.HasComponent<DeterministicVelocity>(entity))
                {
                    entityData.Velocity = world.GetComponent<DeterministicVelocity>(entity);
                    entityData.HasVelocity = true;
                }

                if (world.HasComponent<DeterministicHealth>(entity))
                {
                    entityData.Health = world.GetComponent<DeterministicHealth>(entity);
                    entityData.HasHealth = true;
                }

                snapshot.Entities.Add(entityData);
            }
        }

        return snapshot;
    }

    private void AssertWorldsIdentical(World world1, World world2)
    {
        var snapshot1 = CaptureWorldSnapshot(world1);
        var snapshot2 = CaptureWorldSnapshot(world2);
        AssertSnapshotsIdentical(snapshot1, snapshot2, "Worlds are not identical");
    }

    private void AssertSnapshotsIdentical(WorldSnapshot snapshot1, WorldSnapshot snapshot2, string message)
    {
        Assert.That(snapshot1.Entities.Count, Is.EqualTo(snapshot2.Entities.Count), $"{message}: Entity count differs");

        // Sort by entity ID for consistent comparison
        snapshot1.Entities.Sort((a, b) => a.Entity.Id.CompareTo(b.Entity.Id));
        snapshot2.Entities.Sort((a, b) => a.Entity.Id.CompareTo(b.Entity.Id));

        for (int i = 0; i < snapshot1.Entities.Count; i++)
        {
            var e1 = snapshot1.Entities[i];
            var e2 = snapshot2.Entities[i];

            Assert.That(e1.Entity, Is.EqualTo(e2.Entity), $"{message}: Entity {i} ID differs");
            Assert.That(e1.HasPosition, Is.EqualTo(e2.HasPosition), $"{message}: Entity {i} Position component presence differs");
            Assert.That(e1.HasVelocity, Is.EqualTo(e2.HasVelocity), $"{message}: Entity {i} Velocity component presence differs");
            Assert.That(e1.HasHealth, Is.EqualTo(e2.HasHealth), $"{message}: Entity {i} Health component presence differs");

            if (e1.HasPosition)
            {
                Assert.That(e1.Position.X, Is.EqualTo(e2.Position.X).Within(0.00001f), $"{message}: Entity {i} Position.X differs");
                Assert.That(e1.Position.Y, Is.EqualTo(e2.Position.Y).Within(0.00001f), $"{message}: Entity {i} Position.Y differs");
            }

            if (e1.HasVelocity)
            {
                Assert.That(e1.Velocity.X, Is.EqualTo(e2.Velocity.X).Within(0.00001f), $"{message}: Entity {i} Velocity.X differs");
                Assert.That(e1.Velocity.Y, Is.EqualTo(e2.Velocity.Y).Within(0.00001f), $"{message}: Entity {i} Velocity.Y differs");
            }

            if (e1.HasHealth)
            {
                Assert.That(e1.Health.Current, Is.EqualTo(e2.Health.Current), $"{message}: Entity {i} Health.Current differs");
                Assert.That(e1.Health.Maximum, Is.EqualTo(e2.Health.Maximum), $"{message}: Entity {i} Health.Maximum differs");
            }
        }
    }
}

// Test Components
public struct DeterministicPosition
{
    public float X, Y;
}

public struct DeterministicVelocity
{
    public float X, Y;
}

public struct DeterministicHealth
{
    public int Current, Maximum;
}

public struct DeterministicEventTrigger
{
    public int TriggerFrame;
}

public struct DeterministicEvent
{
    public int Id;
    public float Value;
}

// Test Systems
public class DeterministicMovementSystem : ISystem
{
    private readonly Random _random;

    public DeterministicMovementSystem(int seed)
    {
        _random = new Random(seed);
    }

    public void Update(World world, float deltaTime)
    {
        var query = world.Query().With<DeterministicPosition>().With<DeterministicVelocity>();
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<DeterministicPosition>();
            var velocities = chunk.GetSpan<DeterministicVelocity>();

            for (int i = 0; i < chunk.Count; i++)
            {
                // Deterministic movement with some randomness
                positions[i].X += velocities[i].X * deltaTime;
                positions[i].Y += velocities[i].Y * deltaTime;

                // Add deterministic "noise"
                var noise = (float)(_random.NextDouble() * 2 - 1) * 0.1f;
                velocities[i].X += noise * deltaTime;
                velocities[i].Y += noise * deltaTime;
            }
        }
    }
}

public class DeterministicPhysicsSystem : ISystem
{
    private readonly Random _random;

    public DeterministicPhysicsSystem(int seed)
    {
        _random = new Random(seed);
    }

    public void Update(World world, float deltaTime)
    {
        var query = world.Query().With<DeterministicVelocity>();
        foreach (var chunk in query.Chunks())
        {
            var velocities = chunk.GetSpan<DeterministicVelocity>();
            for (int i = 0; i < chunk.Count; i++)
            {
                // Apply deterministic friction
                velocities[i].X *= 0.98f;
                velocities[i].Y *= 0.98f;
            }
        }
    }
}

public class DeterministicAISystem : ISystem
{
    private readonly Random _random;

    public DeterministicAISystem(int seed)
    {
        _random = new Random(seed);
    }

    public void Update(World world, float deltaTime)
    {
        var query = world.Query().With<DeterministicHealth>();
        foreach (var chunk in query.Chunks())
        {
            var healths = chunk.GetSpan<DeterministicHealth>();
            for (int i = 0; i < chunk.Count; i++)
            {
                // Deterministic health regeneration
                if (_random.Next(100) < 10) // 10% chance
                {
                    healths[i].Current = Math.Min(healths[i].Maximum, healths[i].Current + 1);
                }
            }
        }
    }
}

public class DeterministicFloatSystem : ISystem
{
    public void Update(World world, float deltaTime)
    {
        var query = world.Query().With<DeterministicPosition>().With<DeterministicVelocity>();
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<DeterministicPosition>();
            var velocities = chunk.GetSpan<DeterministicVelocity>();

            for (int i = 0; i < chunk.Count; i++)
            {
                // Complex floating-point operations
                float angle = (float)Math.Atan2(positions[i].Y, positions[i].X);
                float magnitude = (float)Math.Sqrt(positions[i].X * positions[i].X + positions[i].Y * positions[i].Y);
                
                angle += deltaTime;
                magnitude *= 1.001f;
                
                positions[i].X = magnitude * (float)Math.Cos(angle);
                positions[i].Y = magnitude * (float)Math.Sin(angle);
                
                // More complex operations
                velocities[i].X = (float)(Math.Sin(angle * 3) * Math.Cos(magnitude * 0.1));
                velocities[i].Y = (float)(Math.Cos(angle * 3) * Math.Sin(magnitude * 0.1));
            }
        }
    }
}

public class DeterministicEventSystem : ISystem
{
    private readonly Random _random;
    private int _frameCounter;

    public DeterministicEventSystem(int seed)
    {
        _random = new Random(seed);
    }

    public void Update(World world, float deltaTime)
    {
        var query = world.Query().With<DeterministicEventTrigger>();
        foreach (var chunk in query.Chunks())
        {
            var triggers = chunk.GetSpan<DeterministicEventTrigger>();
            for (int i = 0; i < chunk.Count; i++)
            {
                if (triggers[i].TriggerFrame == _frameCounter)
                {
                    world.Events<DeterministicEvent>().Publish(new DeterministicEvent 
                    { 
                        Id = _random.Next(),
                        Value = (float)_random.NextDouble()
                    });
                }
            }
        }
        _frameCounter++;
    }
}

// Helper Classes
public class WorldSnapshot
{
    public List<EntitySnapshot> Entities { get; } = new List<EntitySnapshot>();
}

public class EntitySnapshot
{
    public Entity Entity;
    public bool HasPosition, HasVelocity, HasHealth;
    public DeterministicPosition Position;
    public DeterministicVelocity Velocity;
    public DeterministicHealth Health;
}