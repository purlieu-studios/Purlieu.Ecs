using NUnit.Framework;
using PurlieuEcs.Core;
using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace Purlieu.Ecs.Tests.Core;

[TestFixture]
public class SNAP_SnapshotTests
{
    private World _world = null!;
    private string _tempDirectory = null!;

    [SetUp]
    public void Setup()
    {
        _world = new World();
        _tempDirectory = Path.Combine(Path.GetTempPath(), "PurlieuEcsTests", Guid.NewGuid().ToString());
        Directory.CreateDirectory(_tempDirectory);
    }

    [TearDown]
    public void Cleanup()
    {
        _world = null!;
        if (Directory.Exists(_tempDirectory))
        {
            Directory.Delete(_tempDirectory, true);
        }
    }

    [Test]
    public void SNAP_BasicSaveLoad_RestoresWorldState()
    {
        // Create a world with various entities and components
        var entities = CreateTestWorld(_world);
        
        var snapshotPath = Path.Combine(_tempDirectory, "basic_test.snap");
        
        // Save world state
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath);
        
        Assert.That(File.Exists(snapshotPath), Is.True);
        
        // Create new world and load snapshot
        var newWorld = new World();
        snapshot.LoadWorld(newWorld, snapshotPath);
        
        // Verify worlds are identical
        AssertWorldsIdentical(_world, newWorld, entities);
    }

    [Test]
    public void SNAP_EmptyWorld_SaveLoad()
    {
        // Test save/load of empty world
        var snapshotPath = Path.Combine(_tempDirectory, "empty_test.snap");
        
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath);
        
        var newWorld = new World();
        snapshot.LoadWorld(newWorld, snapshotPath);
        
        // Both worlds should be empty
        Assert.That(_world.Query().Count(), Is.EqualTo(0));
        Assert.That(newWorld.Query().Count(), Is.EqualTo(0));
    }

    [Test]
    public void SNAP_LargeWorld_SaveLoad()
    {
        // Create large world with many entities
        var entities = new List<Entity>();
        var random = new Random(12345);
        
        for (int i = 0; i < 10000; i++)
        {
            var entity = _world.CreateEntity();
            entities.Add(entity);
            
            _world.AddComponent(entity, new SnapshotPosition { X = random.NextSingle() * 1000, Y = random.NextSingle() * 1000 });
            
            if (i % 2 == 0)
                _world.AddComponent(entity, new SnapshotVelocity { X = random.NextSingle() * 10, Y = random.NextSingle() * 10 });
                
            if (i % 3 == 0)
                _world.AddComponent(entity, new SnapshotHealth { Current = random.Next(1, 100), Maximum = 100 });
                
            if (i % 5 == 0)
                _world.AddComponent(entity, new SnapshotTag());
        }
        
        var snapshotPath = Path.Combine(_tempDirectory, "large_test.snap");
        
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath);
        stopwatch.Stop();
        
        Assert.That(stopwatch.ElapsedMilliseconds, Is.LessThan(1000), "Large world save should complete within 1 second");
        
        stopwatch.Restart();
        var newWorld = new World();
        snapshot.LoadWorld(newWorld, snapshotPath);
        stopwatch.Stop();
        
        Assert.That(stopwatch.ElapsedMilliseconds, Is.LessThan(1000), "Large world load should complete within 1 second");
        
        AssertWorldsIdentical(_world, newWorld, entities);
    }

    [Test]
    public void SNAP_SnapshotMetadata_Preserved()
    {
        CreateTestWorld(_world);
        
        var snapshotPath = Path.Combine(_tempDirectory, "metadata_test.snap");
        var metadata = new SnapshotMetadata
        {
            Version = "1.0.0",
            Timestamp = DateTime.UtcNow,
            GameVersion = "TestGame v2.1",
            Description = "Unit test snapshot",
            CustomData = new Dictionary<string, object>
            {
                { "level", 42 },
                { "player_name", "TestPlayer" },
                { "difficulty", "Hard" }
            }
        };
        
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath, metadata);
        
        var newWorld = new World();
        var loadedMetadata = snapshot.LoadWorld(newWorld, snapshotPath);
        
        Assert.That(loadedMetadata, Is.Not.Null);
        Assert.That(loadedMetadata.Version, Is.EqualTo(metadata.Version));
        Assert.That(loadedMetadata.GameVersion, Is.EqualTo(metadata.GameVersion));
        Assert.That(loadedMetadata.Description, Is.EqualTo(metadata.Description));
        Assert.That(loadedMetadata.Timestamp, Is.EqualTo(metadata.Timestamp).Within(TimeSpan.FromSeconds(1)));
        
        Assert.That(loadedMetadata.CustomData["level"], Is.EqualTo(42));
        Assert.That(loadedMetadata.CustomData["player_name"], Is.EqualTo("TestPlayer"));
        Assert.That(loadedMetadata.CustomData["difficulty"], Is.EqualTo("Hard"));
    }

    [Test]
    public void SNAP_CompressedSnapshot_SmallerSize()
    {
        CreateTestWorld(_world);
        
        var uncompressedPath = Path.Combine(_tempDirectory, "uncompressed.snap");
        var compressedPath = Path.Combine(_tempDirectory, "compressed.snap");
        
        var snapshot = new MockWorldSnapshot();
        
        // Save without compression
        snapshot.SaveWorld(_world, uncompressedPath, compressionLevel: CompressionLevel.None);
        
        // Save with compression
        snapshot.SaveWorld(_world, compressedPath, compressionLevel: CompressionLevel.High);
        
        var uncompressedSize = new FileInfo(uncompressedPath).Length;
        var compressedSize = new FileInfo(compressedPath).Length;
        
        Assert.That(compressedSize, Is.LessThan(uncompressedSize), "Compressed snapshot should be smaller");
        
        // Verify both can be loaded correctly
        var world1 = new World();
        var world2 = new World();
        
        snapshot.LoadWorld(world1, uncompressedPath);
        snapshot.LoadWorld(world2, compressedPath);
        
        AssertWorldsIdentical(world1, world2, CreateTestWorld(new World()));
    }

    [Test]
    public void SNAP_IncrementalSnapshot_OnlyChanges()
    {
        var entities = CreateTestWorld(_world);
        
        // Save initial snapshot
        var initialPath = Path.Combine(_tempDirectory, "initial.snap");
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, initialPath);
        
        // Modify some entities
        var modifiedEntities = new List<Entity>();
        for (int i = 0; i < 10 && i < entities.Count; i++)
        {
            if (_world.HasComponent<SnapshotPosition>(entities[i]))
            {
                ref var pos = ref _world.GetComponent<SnapshotPosition>(entities[i]);
                pos.X += 100;
                pos.Y += 100;
                modifiedEntities.Add(entities[i]);
            }
        }
        
        // Add new entities
        var newEntities = new List<Entity>();
        for (int i = 0; i < 5; i++)
        {
            var entity = _world.CreateEntity();
            _world.AddComponent(entity, new SnapshotPosition { X = 999 + i, Y = 999 + i });
            newEntities.Add(entity);
            entities.Add(entity);
        }
        
        // Save incremental snapshot
        var incrementalPath = Path.Combine(_tempDirectory, "incremental.snap");
        snapshot.SaveIncrementalWorld(_world, initialPath, incrementalPath);
        
        var incrementalSize = new FileInfo(incrementalPath).Length;
        var fullSize = new FileInfo(initialPath).Length;
        
        Assert.That(incrementalSize, Is.LessThan(fullSize), "Incremental snapshot should be smaller");
        
        // Load incremental snapshot
        var newWorld = new World();
        snapshot.LoadWorld(newWorld, incrementalPath);
        
        AssertWorldsIdentical(_world, newWorld, entities);
    }

    [Test]
    public void SNAP_VersionCompatibility_HandlesMismatch()
    {
        CreateTestWorld(_world);
        
        var snapshotPath = Path.Combine(_tempDirectory, "version_test.snap");
        var metadata = new SnapshotMetadata { Version = "999.0.0" }; // Future version
        
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath, metadata);
        
        var newWorld = new World();
        
        // Should handle version mismatch gracefully
        Assert.DoesNotThrow(() =>
        {
            var loadedMetadata = snapshot.LoadWorld(newWorld, snapshotPath);
            Assert.That(loadedMetadata.Version, Is.EqualTo("999.0.0"));
        });
    }

    [Test]
    public void SNAP_CorruptedFile_HandlesGracefully()
    {
        var corruptedPath = Path.Combine(_tempDirectory, "corrupted.snap");
        
        // Create corrupted file
        File.WriteAllText(corruptedPath, "This is not a valid snapshot file");
        
        var snapshot = new MockWorldSnapshot();
        var newWorld = new World();
        
        Assert.Throws<InvalidSnapshotFormatException>(() =>
        {
            snapshot.LoadWorld(newWorld, corruptedPath);
        });
    }

    [Test]
    public void SNAP_SaveLoad_PreservesEntityOrder()
    {
        var entities = CreateTestWorld(_world);
        
        var snapshotPath = Path.Combine(_tempDirectory, "order_test.snap");
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, snapshotPath);
        
        var newWorld = new World();
        snapshot.LoadWorld(newWorld, snapshotPath);
        
        // Verify entity order is preserved
        var originalOrder = new List<Entity>();
        var loadedOrder = new List<Entity>();
        
        var originalQuery = _world.Query().With<SnapshotPosition>();
        foreach (var chunk in originalQuery.Chunks())
        {
            var chunkEntities = chunk.GetEntities();
            for (int i = 0; i < chunk.Count; i++)
            {
                originalOrder.Add(chunkEntities[i]);
            }
        }
        
        var loadedQuery = newWorld.Query().With<SnapshotPosition>();
        foreach (var chunk in loadedQuery.Chunks())
        {
            var chunkEntities = chunk.GetEntities();
            for (int i = 0; i < chunk.Count; i++)
            {
                loadedOrder.Add(chunkEntities[i]);
            }
        }
        
        Assert.That(loadedOrder.Count, Is.EqualTo(originalOrder.Count));
        // Note: Entity IDs might differ but component data should match
    }

    [Test]
    public void SNAP_MultipleSnapshots_NoInterference()
    {
        var entities1 = CreateTestWorld(_world);
        
        var path1 = Path.Combine(_tempDirectory, "world1.snap");
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, path1);
        
        // Create different world
        var world2 = new World();
        var entities2 = CreateDifferentTestWorld(world2);
        
        var path2 = Path.Combine(_tempDirectory, "world2.snap");
        snapshot.SaveWorld(world2, path2);
        
        // Load both snapshots into separate worlds
        var loadedWorld1 = new World();
        var loadedWorld2 = new World();
        
        snapshot.LoadWorld(loadedWorld1, path1);
        snapshot.LoadWorld(loadedWorld2, path2);
        
        // Verify each loaded world matches its original
        AssertWorldsIdentical(_world, loadedWorld1, entities1);
        AssertWorldsIdentical(world2, loadedWorld2, entities2);
        
        // Verify worlds are different from each other
        Assert.That(loadedWorld1.Query().Count(), Is.Not.EqualTo(loadedWorld2.Query().Count()));
    }

    [Test]
    public void SNAP_SnapshotChain_MultipleVersions()
    {
        var entities = CreateTestWorld(_world);
        
        var basePath = Path.Combine(_tempDirectory, "base.snap");
        var snapshot = new MockWorldSnapshot();
        snapshot.SaveWorld(_world, basePath);
        
        // Make changes and create chain of snapshots
        var snapshots = new List<string>();
        for (int version = 1; version <= 5; version++)
        {
            // Modify world
            ModifyWorldForVersion(_world, version);
            
            var versionPath = Path.Combine(_tempDirectory, $"version_{version}.snap");
            snapshot.SaveWorld(_world, versionPath);
            snapshots.Add(versionPath);
        }
        
        // Verify each version can be loaded
        for (int i = 0; i < snapshots.Count; i++)
        {
            var testWorld = new World();
            snapshot.LoadWorld(testWorld, snapshots[i]);
            
            // Basic validation - should have some entities
            Assert.That(testWorld.Query().Count(), Is.GreaterThan(0));
        }
    }

    // Helper Methods
    private List<Entity> CreateTestWorld(World world)
    {
        var entities = new List<Entity>();
        var random = new Random(12345);
        
        for (int i = 0; i < 100; i++)
        {
            var entity = world.CreateEntity();
            entities.Add(entity);
            
            world.AddComponent(entity, new SnapshotPosition { X = random.NextSingle() * 100, Y = random.NextSingle() * 100 });
            
            if (i % 2 == 0)
                world.AddComponent(entity, new SnapshotVelocity { X = random.NextSingle() * 5, Y = random.NextSingle() * 5 });
                
            if (i % 3 == 0)
                world.AddComponent(entity, new SnapshotHealth { Current = random.Next(10, 100), Maximum = 100 });
                
            if (i % 5 == 0)
                world.AddComponent(entity, new SnapshotTag());
        }
        
        return entities;
    }

    private List<Entity> CreateDifferentTestWorld(World world)
    {
        var entities = new List<Entity>();
        var random = new Random(54321); // Different seed
        
        for (int i = 0; i < 50; i++) // Different count
        {
            var entity = world.CreateEntity();
            entities.Add(entity);
            
            world.AddComponent(entity, new SnapshotPosition { X = random.NextSingle() * 200, Y = random.NextSingle() * 200 });
            world.AddComponent(entity, new SnapshotHealth { Current = random.Next(50, 150), Maximum = 150 });
        }
        
        return entities;
    }

    private void ModifyWorldForVersion(World world, int version)
    {
        var query = world.Query().With<SnapshotPosition>();
        foreach (var chunk in query.Chunks())
        {
            var positions = chunk.GetSpan<SnapshotPosition>();
            for (int i = 0; i < chunk.Count; i++)
            {
                positions[i].X += version;
                positions[i].Y += version;
            }
        }
    }

    private void AssertWorldsIdentical(World world1, World world2, List<Entity> originalEntities)
    {
        var count1 = world1.Query().Count();
        var count2 = world2.Query().Count();
        
        Assert.That(count1, Is.EqualTo(count2), "Entity counts differ");
        
        // Compare component data (entity IDs may differ)
        var positions1 = new List<SnapshotPosition>();
        var positions2 = new List<SnapshotPosition>();
        
        var posQuery1 = world1.Query().With<SnapshotPosition>();
        foreach (var chunk in posQuery1.Chunks())
        {
            var span = chunk.GetSpan<SnapshotPosition>();
            for (int i = 0; i < chunk.Count; i++)
            {
                positions1.Add(span[i]);
            }
        }
        
        var posQuery2 = world2.Query().With<SnapshotPosition>();
        foreach (var chunk in posQuery2.Chunks())
        {
            var span = chunk.GetSpan<SnapshotPosition>();
            for (int i = 0; i < chunk.Count; i++)
            {
                positions2.Add(span[i]);
            }
        }
        
        positions1.Sort((a, b) => a.X.CompareTo(b.X));
        positions2.Sort((a, b) => a.X.CompareTo(b.X));
        
        Assert.That(positions1.Count, Is.EqualTo(positions2.Count));
        for (int i = 0; i < positions1.Count; i++)
        {
            Assert.That(positions1[i].X, Is.EqualTo(positions2[i].X).Within(0.001f));
            Assert.That(positions1[i].Y, Is.EqualTo(positions2[i].Y).Within(0.001f));
        }
    }
}

// Test Components
public struct SnapshotPosition
{
    public float X, Y;
}

public struct SnapshotVelocity
{
    public float X, Y;
}

public struct SnapshotHealth
{
    public int Current, Maximum;
}

public struct SnapshotTag { }

// Mock Snapshot Classes (to be implemented in actual ECS)
public class MockWorldSnapshot
{
    public void SaveWorld(World world, string path, SnapshotMetadata? metadata = null, CompressionLevel compressionLevel = CompressionLevel.Medium)
    {
        // Mock implementation - would serialize world state to file
        using var stream = new FileStream(path, FileMode.Create);
        using var writer = new BinaryWriter(stream);
        
        // Write header
        writer.Write("PURLIEU_ECS_SNAPSHOT");
        writer.Write(metadata?.Version ?? "1.0.0");
        writer.Write(metadata?.Timestamp.ToBinary() ?? DateTime.UtcNow.ToBinary());
        writer.Write(metadata?.GameVersion ?? "");
        writer.Write(metadata?.Description ?? "");
        
        // Write custom data
        writer.Write(metadata?.CustomData?.Count ?? 0);
        if (metadata?.CustomData != null)
        {
            foreach (var kvp in metadata.CustomData)
            {
                writer.Write(kvp.Key);
                writer.Write(kvp.Value?.ToString() ?? "");
            }
        }
        
        // Write entities and components
        var entityCount = world.Query().Count();
        writer.Write(entityCount);
        
        var query = world.Query();
        foreach (var chunk in query.Chunks())
        {
            var entities = chunk.GetEntities();
            for (int i = 0; i < chunk.Count; i++)
            {
                var entity = entities[i];
                writer.Write(entity.Id);
                writer.Write(entity.Version);
                
                // Write components
                WriteComponentIfExists<SnapshotPosition>(world, entity, writer);
                WriteComponentIfExists<SnapshotVelocity>(world, entity, writer);
                WriteComponentIfExists<SnapshotHealth>(world, entity, writer);
                WriteComponentIfExists<SnapshotTag>(world, entity, writer);
            }
        }
    }
    
    private void WriteComponentIfExists<T>(World world, Entity entity, BinaryWriter writer) where T : struct
    {
        if (world.HasComponent<T>(entity))
        {
            writer.Write(true);
            var component = world.GetComponent<T>(entity);
            
            if (typeof(T) == typeof(SnapshotPosition))
            {
                var pos = (SnapshotPosition)(object)component;
                writer.Write(pos.X);
                writer.Write(pos.Y);
            }
            else if (typeof(T) == typeof(SnapshotVelocity))
            {
                var vel = (SnapshotVelocity)(object)component;
                writer.Write(vel.X);
                writer.Write(vel.Y);
            }
            else if (typeof(T) == typeof(SnapshotHealth))
            {
                var health = (SnapshotHealth)(object)component;
                writer.Write(health.Current);
                writer.Write(health.Maximum);
            }
            else if (typeof(T) == typeof(SnapshotTag))
            {
                // Tag has no data
            }
        }
        else
        {
            writer.Write(false);
        }
    }
    
    public SnapshotMetadata LoadWorld(World world, string path)
    {
        using var stream = new FileStream(path, FileMode.Open);
        using var reader = new BinaryReader(stream);
        
        // Read header
        var header = reader.ReadString();
        if (header != "PURLIEU_ECS_SNAPSHOT")
            throw new InvalidSnapshotFormatException("Invalid snapshot header");
            
        var metadata = new SnapshotMetadata
        {
            Version = reader.ReadString(),
            Timestamp = DateTime.FromBinary(reader.ReadInt64()),
            GameVersion = reader.ReadString(),
            Description = reader.ReadString()
        };
        
        // Read custom data
        var customDataCount = reader.ReadInt32();
        metadata.CustomData = new Dictionary<string, object>();
        for (int i = 0; i < customDataCount; i++)
        {
            var key = reader.ReadString();
            var value = reader.ReadString();
            
            // Try to parse as int first
            if (int.TryParse(value, out var intValue))
                metadata.CustomData[key] = intValue;
            else
                metadata.CustomData[key] = value;
        }
        
        // Read entities
        var entityCount = reader.ReadInt32();
        for (int i = 0; i < entityCount; i++)
        {
            var entityId = reader.ReadUInt32();
            var entityVersion = reader.ReadUInt32();
            
            var entity = world.CreateEntity();
            
            // Read components
            ReadComponentIfExists<SnapshotPosition>(world, entity, reader);
            ReadComponentIfExists<SnapshotVelocity>(world, entity, reader);
            ReadComponentIfExists<SnapshotHealth>(world, entity, reader);
            ReadComponentIfExists<SnapshotTag>(world, entity, reader);
        }
        
        return metadata;
    }
    
    private void ReadComponentIfExists<T>(World world, Entity entity, BinaryReader reader) where T : struct
    {
        if (reader.ReadBoolean())
        {
            if (typeof(T) == typeof(SnapshotPosition))
            {
                var pos = new SnapshotPosition { X = reader.ReadSingle(), Y = reader.ReadSingle() };
                world.AddComponent(entity, (T)(object)pos);
            }
            else if (typeof(T) == typeof(SnapshotVelocity))
            {
                var vel = new SnapshotVelocity { X = reader.ReadSingle(), Y = reader.ReadSingle() };
                world.AddComponent(entity, (T)(object)vel);
            }
            else if (typeof(T) == typeof(SnapshotHealth))
            {
                var health = new SnapshotHealth { Current = reader.ReadInt32(), Maximum = reader.ReadInt32() };
                world.AddComponent(entity, (T)(object)health);
            }
            else if (typeof(T) == typeof(SnapshotTag))
            {
                world.AddComponent(entity, (T)(object)new SnapshotTag());
            }
        }
    }
    
    public void SaveIncrementalWorld(World world, string basePath, string incrementalPath)
    {
        // Mock incremental save - in real implementation would do diff
        SaveWorld(world, incrementalPath);
    }
}

public class SnapshotMetadata
{
    public string Version { get; set; } = "";
    public DateTime Timestamp { get; set; }
    public string GameVersion { get; set; } = "";
    public string Description { get; set; } = "";
    public Dictionary<string, object>? CustomData { get; set; }
}

public enum CompressionLevel
{
    None,
    Low,
    Medium,
    High
}

public class InvalidSnapshotFormatException : Exception
{
    public InvalidSnapshotFormatException(string message) : base(message) { }
}