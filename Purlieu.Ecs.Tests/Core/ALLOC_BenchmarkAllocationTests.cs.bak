using NUnit.Framework;
using PurlieuEcs.Core;
using System;
using System.Diagnostics;

namespace Purlieu.Ecs.Tests.Core;

[TestFixture]
public class ALLOC_BenchmarkAllocationTests
{
    private World _world = null!;
    private Entity[] _entities = null!;

    [SetUp]
    public void Setup()
    {
        _world = new World();
        _entities = new Entity[10000];
        for (int i = 0; i < _entities.Length; i++)
        {
            _entities[i] = _world.CreateEntity();
        }
    }

    [TearDown]
    public void Cleanup()
    {
        _world = null!;
        _entities = null!;
    }

    private void AssertZeroAllocations(Action action)
    {
        // Force garbage collection to clean slate
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();

        long beforeBytes = GC.GetTotalMemory(false);
        long beforeGen0 = GC.CollectionCount(0);
        long beforeGen1 = GC.CollectionCount(1);
        long beforeGen2 = GC.CollectionCount(2);

        action();

        long afterBytes = GC.GetTotalMemory(false);
        long afterGen0 = GC.CollectionCount(0);
        long afterGen1 = GC.CollectionCount(1);
        long afterGen2 = GC.CollectionCount(2);

        long allocatedBytes = afterBytes - beforeBytes;
        long gen0Collections = afterGen0 - beforeGen0;
        long gen1Collections = afterGen1 - beforeGen1;
        long gen2Collections = afterGen2 - beforeGen2;

        Assert.That(gen0Collections, Is.EqualTo(0), 
            $"Gen 0 collections occurred: {gen0Collections}");
        Assert.That(gen1Collections, Is.EqualTo(0), 
            $"Gen 1 collections occurred: {gen1Collections}");
        Assert.That(gen2Collections, Is.EqualTo(0), 
            $"Gen 2 collections occurred: {gen2Collections}");
        
        // Allow small memory fluctuations but flag significant allocations
        Assert.That(Math.Abs(allocatedBytes), Is.LessThan(1024), 
            $"Allocated bytes: {allocatedBytes}. Expected near-zero heap allocations.");
    }

    [Test]
    public void ALLOC_QueryIteration_TwoComponents()
    {
        // Setup: Add components to entities
        for (int i = 0; i < _entities.Length; i++)
        {
            _world.AddComponent(_entities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
            _world.AddComponent(_entities[i], new TestComponentB { X = i * 0.5f, Y = i * 0.7f, Timestamp = i });
        }

        // Test: Query iteration should allocate zero bytes
        AssertZeroAllocations(() =>
        {
            var query = _world.Query().With<TestComponentA>().With<TestComponentB>();
            long sum = 0;
            
            foreach (var chunk in query.Chunks())
            {
                var componentA = chunk.GetSpan<TestComponentA>();
                var componentB = chunk.GetSpan<TestComponentB>();
                
                for (int i = 0; i < chunk.Count; i++)
                {
                    sum += componentA[i].X + componentA[i].Y + (long)componentB[i].X + (long)componentB[i].Y;
                }
            }
        });
    }

    [Test]
    public void ALLOC_QueryIteration_ThreeComponents()
    {
        // Setup: Add components to entities
        for (int i = 0; i < _entities.Length; i++)
        {
            _world.AddComponent(_entities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
            _world.AddComponent(_entities[i], new TestComponentB { X = i * 0.5f, Y = i * 0.7f, Timestamp = i });
            _world.AddComponent(_entities[i], new TestComponentC { IsActive = true, Flags = (byte)(i % 256), Priority = (short)(i % 1000) });
        }

        // Test: Query iteration with three components should allocate zero bytes
        AssertZeroAllocations(() =>
        {
            var query = _world.Query().With<TestComponentA>().With<TestComponentB>().With<TestComponentC>();
            long sum = 0;
            
            foreach (var chunk in query.Chunks())
            {
                var componentA = chunk.GetSpan<TestComponentA>();
                var componentB = chunk.GetSpan<TestComponentB>();
                var componentC = chunk.GetSpan<TestComponentC>();
                
                for (int i = 0; i < chunk.Count; i++)
                {
                    sum += componentA[i].X + componentA[i].Y + (long)componentB[i].X + (long)componentB[i].Y + componentC[i].Priority;
                }
            }
        });
    }

    [Test]
    public void ALLOC_AddRemoveTwoComponents()
    {
        // Prepare entities (this setup can allocate)
        var testEntities = new Entity[1000];
        for (int i = 0; i < testEntities.Length; i++)
        {
            testEntities[i] = _world.CreateEntity();
        }

        // Test: Add/Remove operations should have minimal allocations
        AssertZeroAllocations(() =>
        {
            for (int i = 0; i < testEntities.Length; i++)
            {
                _world.AddComponent(testEntities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
                _world.AddComponent(testEntities[i], new TestComponentB { X = i * 0.5f, Y = i * 0.7f, Timestamp = i });
            }
            
            for (int i = 0; i < testEntities.Length; i++)
            {
                _world.RemoveComponent<TestComponentA>(testEntities[i]);
                _world.RemoveComponent<TestComponentB>(testEntities[i]);
            }
        });
    }

    [Test]
    public void ALLOC_SystemSchedulerExecution()
    {
        // Setup entities and scheduler
        var scheduler = new PurlieuEcs.Systems.SystemScheduler();
        var system = new TestSystem();
        scheduler.RegisterSystem(system);

        for (int i = 0; i < _entities.Length; i++)
        {
            _world.AddComponent(_entities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
        }

        // Test: System execution should allocate zero bytes in hot path
        AssertZeroAllocations(() =>
        {
            scheduler.UpdatePhase(_world, 0.016f, PurlieuEcs.Systems.GamePhases.Update);
        });
    }

    [Test]
    public void ALLOC_ArchetypeMigration()
    {
        // Prepare entities
        var testEntities = new Entity[1000];
        for (int i = 0; i < testEntities.Length; i++)
        {
            testEntities[i] = _world.CreateEntity();
        }

        // Test: Archetype migration should have minimal allocations
        AssertZeroAllocations(() =>
        {
            for (int i = 0; i < testEntities.Length; i++)
            {
                var entity = testEntities[i];
                
                // Empty -> A
                _world.AddComponent(entity, new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
                
                // A -> A+B
                _world.AddComponent(entity, new TestComponentB { X = i * 0.5f, Y = i * 0.7f, Timestamp = i });
                
                // A+B -> B (remove A)
                _world.RemoveComponent<TestComponentA>(entity);
            }
        });
    }

    [Test]
    public void ALLOC_GetSpanOperations()
    {
        // Setup: Add components
        for (int i = 0; i < _entities.Length; i++)
        {
            _world.AddComponent(_entities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
        }

        // Test: GetSpan operations should allocate zero bytes
        AssertZeroAllocations(() =>
        {
            var query = _world.Query().With<TestComponentA>();
            
            foreach (var chunk in query.Chunks())
            {
                var span = chunk.GetSpan<TestComponentA>();
                // Access elements to ensure span is actually used
                for (int i = 0; i < chunk.Count; i++)
                {
                    var component = span[i];
                    var sum = component.X + component.Y + component.Z;
                }
            }
        });
    }

    [Test]
    public void ALLOC_QueryCreation()
    {
        // Test: Query creation should have minimal allocations
        AssertZeroAllocations(() =>
        {
            for (int i = 0; i < 1000; i++)
            {
                var query = _world.Query().With<TestComponentA>().With<TestComponentB>().Without<TestComponentC>();
                // Force query to be used
                var count = query.Count();
            }
        });
    }

    [PurlieuEcs.Systems.GamePhase(PurlieuEcs.Systems.GamePhases.Update, 100)]
    private class TestSystem : PurlieuEcs.Systems.ISystem
    {
        public void Update(World world, float deltaTime)
        {
            var query = world.Query().With<TestComponentA>();
            foreach (var chunk in query.Chunks())
            {
                var components = chunk.GetSpan<TestComponentA>();
                for (int i = 0; i < chunk.Count; i++)
                {
                    components[i].Value += deltaTime;
                }
            }
        }
    }
}