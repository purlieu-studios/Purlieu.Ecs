using NUnit.Framework;
using PurlieuEcs.Core;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;

namespace Purlieu.Ecs.Tests.Core;

[TestFixture]
public class PERF_IteratorPoolingTests
{
    private World _world = null!;
    private Entity[] _entities = null!;

    [SetUp]
    public void Setup()
    {
        _world = new World();
        _entities = new Entity[10000];
        for (int i = 0; i < _entities.Length; i++)
        {
            _entities[i] = _world.CreateEntity();
            _world.AddComponent(_entities[i], new TestComponentA { X = i, Y = i * 2, Z = i * 3, Value = i * 0.1f });
            if (i % 2 == 0)
            {
                _world.AddComponent(_entities[i], new TestComponentB { X = i * 0.5f, Y = i * 0.7f, Timestamp = i });
            }
        }
    }

    [TearDown]
    public void Cleanup()
    {
        _world = null!;
        _entities = null!;
    }

    [Test]
    public void PERF_ChunkIterator_IsRefStruct()
    {
        var query = _world.Query().With<TestComponentA>();
        var chunks = query.Chunks();
        
        var enumeratorType = chunks.GetType();
        Assert.That(enumeratorType.IsValueType, Is.True, 
            "Chunk enumerator should be a value type (struct)");

        // Check if it's a ref struct by looking for ref-like behavior
        var typeInfo = enumeratorType.GetTypeInfo();
        var isByRefLike = typeInfo.GetCustomAttribute<System.Runtime.CompilerServices.IsByRefLikeAttribute>() != null;
        
        Assert.That(isByRefLike, Is.True, 
            "Chunk enumerator should be a ref struct to prevent boxing and enable pooling");
    }

    [Test]
    public void PERF_ForeachNoBoxing()
    {
        // This test verifies that foreach over chunks doesn't cause boxing
        var query = _world.Query().With<TestComponentA>();
        
        // Force garbage collection to clean slate
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        long beforeBytes = GC.GetTotalMemory(false);
        long beforeGen0 = GC.CollectionCount(0);
        
        // Iterate multiple times to stress test
        for (int iteration = 0; iteration < 100; iteration++)
        {
            foreach (var chunk in query.Chunks())
            {
                var span = chunk.GetSpan<TestComponentA>();
                if (span.Length > 0)
                {
                    // Minimal work to prevent optimization
                    var _ = span[0].X;
                }
            }
        }
        
        long afterBytes = GC.GetTotalMemory(false);
        long afterGen0 = GC.CollectionCount(0);
        
        long allocatedBytes = afterBytes - beforeBytes;
        long gen0Collections = afterGen0 - beforeGen0;
        
        Assert.That(gen0Collections, Is.EqualTo(0), 
            "No garbage collections should occur during foreach iteration");
        Assert.That(Math.Abs(allocatedBytes), Is.LessThan(1024), 
            $"Minimal heap allocation expected, got {allocatedBytes} bytes");
    }

    [Test]
    public void PERF_IteratorReuse_Performance()
    {
        var query = _world.Query().With<TestComponentA>();
        
        // Measure performance of repeated iteration
        var stopwatch = Stopwatch.StartNew();
        int totalChunks = 0;
        
        for (int iteration = 0; iteration < 1000; iteration++)
        {
            foreach (var chunk in query.Chunks())
            {
                totalChunks++;
                // Minimal work
                var count = chunk.Count;
            }
        }
        
        stopwatch.Stop();
        
        Assert.That(totalChunks, Is.GreaterThan(0));
        
        var nsPerIteration = (stopwatch.ElapsedTicks * 1000000000.0) / (Stopwatch.Frequency * 1000);
        Assert.That(nsPerIteration, Is.LessThan(50000), 
            $"Expected <50Î¼s per full iteration, got {nsPerIteration:F0}ns. Iterator may not be efficiently pooled.");
    }

    [Test]
    public void PERF_NestedIteration_NoBoxing()
    {
        // Test nested foreach scenarios that could cause boxing issues
        var queryA = _world.Query().With<TestComponentA>();
        var queryB = _world.Query().With<TestComponentB>();
        
        GC.Collect();
        long beforeBytes = GC.GetTotalMemory(false);
        long beforeGen0 = GC.CollectionCount(0);
        
        foreach (var chunkA in queryA.Chunks())
        {
            foreach (var chunkB in queryB.Chunks())
            {
                // Simulate some work
                var spanA = chunkA.GetSpan<TestComponentA>();
                var spanB = chunkB.GetSpan<TestComponentB>();
                
                if (spanA.Length > 0 && spanB.Length > 0)
                {
                    var _ = spanA[0].X + (int)spanB[0].X;
                }
            }
        }
        
        long afterBytes = GC.GetTotalMemory(false);
        long afterGen0 = GC.CollectionCount(0);
        
        Assert.That(afterGen0 - beforeGen0, Is.EqualTo(0), 
            "Nested iteration should not cause garbage collection");
        Assert.That(Math.Abs(afterBytes - beforeBytes), Is.LessThan(2048), 
            "Nested iteration should have minimal allocation overhead");
    }

    [Test]
    public void PERF_IteratorState_Reset()
    {
        // Test that iterator state is properly reset between uses
        var query = _world.Query().With<TestComponentA>();
        
        // First iteration
        int firstCount = 0;
        foreach (var chunk in query.Chunks())
        {
            firstCount += chunk.Count;
        }
        
        // Second iteration should yield same results
        int secondCount = 0;
        foreach (var chunk in query.Chunks())
        {
            secondCount += chunk.Count;
        }
        
        Assert.That(secondCount, Is.EqualTo(firstCount), 
            "Iterator should be properly reset between iterations");
        
        // Third iteration with different pattern
        int thirdCount = 0;
        var chunks = query.Chunks();
        foreach (var chunk in chunks)
        {
            thirdCount += chunk.Count;
            break; // Early exit
        }
        
        // Fourth iteration should still work correctly
        int fourthCount = 0;
        foreach (var chunk in query.Chunks())
        {
            fourthCount += chunk.Count;
        }
        
        Assert.That(fourthCount, Is.EqualTo(firstCount), 
            "Iterator should handle early exit and subsequent reuse correctly");
    }

    [Test]
    public void PERF_ManualIterator_RefStruct()
    {
        // Test manual iterator usage to verify ref struct behavior
        var query = _world.Query().With<TestComponentA>();
        var chunks = query.Chunks();
        
        // Manual iteration
        var enumerator = chunks.GetEnumerator();
        int manualCount = 0;
        
        while (enumerator.MoveNext())
        {
            var chunk = enumerator.Current;
            manualCount += chunk.Count;
        }
        
        // Compare with foreach
        int foreachCount = 0;
        foreach (var chunk in query.Chunks())
        {
            foreachCount += chunk.Count;
        }
        
        Assert.That(manualCount, Is.EqualTo(foreachCount), 
            "Manual iteration should yield same results as foreach");
    }

    [Test]
    public void PERF_ConcurrentIteration_Safety()
    {
        // Test that multiple concurrent iterations work correctly
        var query = _world.Query().With<TestComponentA>();
        
        var results = new List<int>();
        
        // Start multiple iterations
        var enum1 = query.Chunks().GetEnumerator();
        var enum2 = query.Chunks().GetEnumerator();
        
        // Interleave iteration
        bool hasNext1 = enum1.MoveNext();
        bool hasNext2 = enum2.MoveNext();
        
        while (hasNext1 || hasNext2)
        {
            if (hasNext1)
            {
                results.Add(enum1.Current.Count);
                hasNext1 = enum1.MoveNext();
            }
            
            if (hasNext2)
            {
                results.Add(enum2.Current.Count);
                hasNext2 = enum2.MoveNext();
            }
        }
        
        // Should have processed all chunks twice
        Assert.That(results.Count, Is.GreaterThan(0));
        
        // Total should be double the entity count
        var totalProcessed = results.Sum();
        Assert.That(totalProcessed, Is.EqualTo(_entities.Length * 2), 
            "Concurrent iteration should process all entities twice");
    }

    [Test]
    public void PERF_HighFrequencyIteration_NoLeaks()
    {
        // Test high-frequency iteration for memory leaks
        var query = _world.Query().With<TestComponentA>();
        
        GC.Collect();
        long initialMemory = GC.GetTotalMemory(false);
        
        // Perform many short iterations
        for (int i = 0; i < 10000; i++)
        {
            foreach (var chunk in query.Chunks())
            {
                // Minimal work, early exit
                var _ = chunk.Count;
                break;
            }
        }
        
        // Force collection and measure
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        long finalMemory = GC.GetTotalMemory(false);
        long memoryGrowth = finalMemory - initialMemory;
        
        Assert.That(Math.Abs(memoryGrowth), Is.LessThan(10240), 
            $"Memory growth should be minimal after high-frequency iteration. Growth: {memoryGrowth} bytes");
    }

    [Test]
    public void PERF_IteratorDisposal_RefStruct()
    {
        // Test that ref struct iterators are properly disposed
        var query = _world.Query().With<TestComponentA>();
        
        // This should compile and not require explicit disposal for ref structs
        using (var enumerator = query.Chunks().GetEnumerator())
        {
            while (enumerator.MoveNext())
            {
                var chunk = enumerator.Current;
                var _ = chunk.Count;
                break; // Early exit
            }
        }
        
        // Test that disposal doesn't interfere with subsequent iterations
        int count = 0;
        foreach (var chunk in query.Chunks())
        {
            count += chunk.Count;
        }
        
        Assert.That(count, Is.EqualTo(_entities.Length), 
            "Iterator disposal should not affect subsequent iterations");
    }
}